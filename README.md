![Robodk](https://github.com/user-attachments/assets/22d2c19c-e174-446e-b82c-8880e2228238)<!-- ✦✦✦ FUTURE IS AUTOMATED ✦✦✦ -->
<!-- Banner superior “neón” -->
<p align="center">
  <!-- El banner se genera usando capsule-render con colores adaptados al Laboratorio 2 -->
  <img src="https://capsule-render.vercel.app/api?type=waving&height=140&color=0:04041A,50:14213D,100:0A4D68&text=Laboratorio%20Rob%C3%B3tica%202&fontColor=E0FBFC&fontAlign=50&fontAlignY=30&desc=An%C3%A1lisis%20y%20Operaci%C3%B3n%20del%20Manipulador%20Motoman%20MH6&descAlign=50&descAlignY=60" alt="header" />
</p>

<h1 align="center">🤖 LABORATORIO ROBÓTICA 2 – ANÁLISIS Y OPERACIÓN DEL MANIPULADOR MOTOMAN MH6</h1>

<p align="center">
  <img src="https://img.shields.io/badge/RoboDK-Simulation-green?style=for-the-badge" />
  <img src="https://img.shields.io/badge/Motoman-MH6-blue?style=for-the-badge" />
  <img src="https://img.shields.io/badge/Industrial-Robotics-orange?style=for-the-badge" />
</p>

<!-- Línea de texto mecanografiado (animado) -->
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&weight=700&size=20&pause=1500&duration=3500&color=00E5FF&center=true&vCenter=true&width=900&lines=Rob%C3%B3tica+Industrial+2025%E2%80%93II;Motoman+MH6+%E2%80%A2+RoboDK+%E2%80%A2+RobotStudio;Comparaci%C3%B3n+de+manipuladores+y+trayectoria+polar" alt="typing" />
</p>

---

### 🛰️ Descripción general

Este repositorio implementa el **Laboratorio No. 2** de *Robótica Industrial 2025‑II*: **análisis y operación del manipulador Motoman MH6**, comparación con **ABB IRB140**, práctica de **movimientos manuales**, **cambio de velocidades**, y **programación/ejecución de una trayectoria polar** en **RoboDK** con demostración virtual y **ejecución física** del Motoman desde el PC.

---

## 🎯 Resultados de aprendizaje
- Comparar características técnicas entre **Motoman MH6** y **ABB IRB140**.
- Identificar y describir **home1** y **home2** del Motoman MH6.
- Realizar **movimientos manuales** en modos articular/cartesiano (traslación y rotación).
- Configurar y cambiar **niveles de velocidad** para enseñanza.
- Explicar **aplicaciones de RoboDK** y su **comunicación** con el manipulador.
- Analizar diferencias **RoboDK vs RobotStudio**.
- Diseñar, simular y ejecutar **trayectoria polar**; registrar evidencia en video.

---

## 🧑‍🚀 Equipo
<!-- ===== INICIO BLOQUE ANIMACIONES EQUIPO (una animación por línea) ===== -->

<!-- Encabezado: Integrantes -->
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&weight=800&size=22&duration=2000&pause=1800&color=00E5FF&center=true&vCenter=true&width=1000&repeat=true&v=1&lines=Integrantes%3A" alt="Integrantes">
</p>

<!-- Nombre 1 -->
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&weight=700&size=20&duration=2400&pause=2000&color=7F5AF0&center=true&vCenter=true&width=1000&repeat=true&v=1&lines=Jorge+Nicol%C3%A1s+Garz%C3%B3n+Acevedo+%E2%80%94+jngarzona%40unal.du.co" alt="Jorge Nicolás Garzón Acevedo">
</p>

<!-- Nombre 2 -->
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&weight=700&size=20&duration=2400&pause=2000&color=7F5AF0&center=true&vCenter=true&width=1000&repeat=true&v=1&lines=Johan+Camilo+Pati%C3%B1o+Mogoll%C3%B3n+%E2%80%94+jopatinom%40unal.edu.co" alt="Johan Camilo Patiño Mogollón">
</p>

<!-- Nombre 3 -->
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&weight=700&size=20&duration=2400&pause=2000&color=7F5AF0&center=true&vCenter=true&width=1000&repeat=true&v=1&lines=Gabriel+Eduardo+Bojaca+Munar+%E2%80%94+gbojaca%40unal.edu.co" alt="Gabriel Eduardo Bojaca Munar">
</p>

<!-- Encabezado: Docentes -->
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&weight=1800&size=22&duration=2000&pause=1800&color=00E5FF&center=true&vCenter=true&width=1000&repeat=true&v=1&lines=Docentes%3A" alt="Docentes">
</p>

<!-- Docente 1 -->
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&weight=700&size=20&duration=2400&pause=2000&color=39D353&center=true&vCenter=true&width=1000&repeat=true&v=1&lines=Manuel+Felipe+Carranza+Montenegro+%E2%80%94+mcarranza%40unal.edu.co" alt="Manuel Felipe Carranza Montenegro">
</p>

<!-- Docente 2 -->
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&weight=700&size=20&duration=2400&pause=2000&color=39D353&center=true&vCenter=true&width=1000&repeat=true&v=1&lines=Pedro+Fabi%C3%A1n+C%C3%A1rdenas+Herrera+%E2%80%94+pfcardenash%40unal.edu.co" alt="Pedro Fabián Cárdenas Herrera">
</p>

<!-- ===== FIN BLOQUE ANIMACIONES EQUIPO ===== -->

## 📊 Cuadro comparativo (MH6 vs IRB140)

| Característica | Motoman MH6 | ABB IRB140 |
|---|---|---|
| **Fabricante** | YASKAWA | ABB |
| **Controlador** | DX100 | IRC5 con RobotWare |
| **Estructura** | Robot articulado | Robot articulado |
| **DOF** | 6 (8 con riel suelo + eje adicional) | 6 |
| **Payload [kg]** | 6 | 6 |
| **Radio de trabajo [mm]** | 1422 | 800 |
| **Repetibilidad [mm]** | ±0,08 | ±0,03 |
| **Peso del manipulador [kg]** | 130 | 98 |
| **Montajes permitidos** | Suelo • Muro • Suspendido | Suelo • Muro • Suspendido |
| **Movimiento angular S:1** | ±170° | ±180° |
| **Movimiento angular L:2** | +155°/–90° | +110°/–90° |
| **Movimiento angular U:3** | +250°/–175° | +50°/–230° |
| **Movimiento angular R:4** | ±180° | ±200° (hasta ±165 rev) |
| **Movimiento angular B:5** | +225°/–45° | ±115° |
| **Movimiento angular T:6** | ±360° | ±400° (hasta ±163 rev) |
| **Velocidad máx. S:1 (°/s)** | 220 | 200 |
| **Velocidad máx. L:2 (°/s)** | 200 | 200 |
| **Velocidad máx. U:3 (°/s)** | 220 | 260 |
| **Velocidad máx. R:4 (°/s)** | 410 | 360 |
| **Velocidad máx. B:5 (°/s)** | 410 | 360 |
| **Velocidad máx. T:6 (°/s)** | 610 | 450 |
| **Aceleración máx. TCP** | — | 57 m/s² (movimiento controlado) |
| **Nivel de protección (IP)** | — | IP67 (hasta muñeca) |
| **Temperatura de operación [°C]** | 0 a +45 | +5 a +45 |
| **Humedad relativa de operación [%]** | 20–80 | ≤95 (sin condensación) |
| **Consumo de potencia** | 1,5 kVA (promedio) | 0,44 kW a 1000 mm/s |
| **Aplicaciones típicas** | Manipulación, alimentación de máquinas, ensamblaje, soldadura, dispensado, empaquetado | Manejo de materiales, ensamblaje, fundición (Foundry Plus 2), clean room, soldadura, pegado |

---

## 🏠 Home1 vs Home2 (Motoman MH6)

- **home1**: postura base/neutral de referencia (U horizontal, R vertical). Facilita la **referencia de inicio** y verificaciones rápidas. Minimiza los torques sobre las articulaciones, permitiendo alargar la vida util de los frenos eléctricos. Usada para embalaje. 
  ![Home 1](https://github.com/user-attachments/assets/e92957dd-9720-4434-ab57-77ba89957654)

- **home2**: postura elevada/retraída para **mantenimiento/cambio de herramienta** y tránsito seguro.
 ![Home 2](https://github.com/user-attachments/assets/6b8ff6a6-8e50-4fdd-bf1b-c4c8c9c53c44)

- **Elección**: usar **home1** para inicio/fin de ciclo y **home2** como aparcamiento/mantenimiento; justificar según layout y seguridad.

---

## Procedimiento detallado de movimientos manuales (articular ↔ cartesiano; traslaciones/rotaciones X‑Y‑Z)

**Objetivo.** Ejecutar enseñanza segura y precisa, dominando cambio de modos de jog, selección de marcos y ejes cartesianos/angulares.

**Secuencia recomendada (Teach Pendant):**
1. **Estado seguro.**
   - Robot en Teach, área despejada, paro de emergencia probado, servo OFF.
   - Selecciona herramienta correcta (TCP) y sistema de coordenadas base/celda.
2. **Modo de jog.**
   - **Articular (JOINT/JOG J1…J6):** cada tecla mueve un eje. Útil para desenganchar singularidades, plegar/desplegar y aproximaciones gruesas.
   - **Cartesiano (XYZ / Rx Ry Rz):**
     - **Traslaciones:** X, Y, Z del marco activo (BASE, USER/FRAME, o TOOL).
     - **Rotaciones:** Rx, Ry, Rz son rotaciones alrededor de los ejes X, Y, Z del marco activo.
   - Cambia entre **BASE/USER/TOOL** según necesites: BASE para desplazamientos globales, USER/FRAME para trayectorias en dispositivos, TOOL para orientar la herramienta sin modificar posición del TCP.
3. **Transición articular → cartesiano.**
   - Desplaza en articular hasta una postura sin riesgos (evitar toques mecánicos y límites).
   - Pasa a cartesiano y **acércate en Z** del marco de trabajo, luego corrige en X/Y y finalmente afina orientación con Rx/Ry/Rz.
4. **Transición cartesiano → articular.**
   - Cuando detectes cercanía a singularidades (p. ej., muñeca con J5≈0°), vuelve a articular para reorientar, y regresa a cartesiano.
5. **Buenas prácticas.**
   - Trabajo cerca de pieza: prioriza **Z** para aproximar/retirar. Mantén **blend = 0** al enseñar puntos críticos.
   - Guarda posiciones como **Targets** con nombres semánticos (APROX_, PUNTO_, RETIRO_). Documenta marco y herramienta usados.
   - Comprueba límites articulares y de velocidad antes de ejecutar en AUTO.

**Proceso detallado de que procedicimento realiar en el Motoman MH6**
1. Energizamos los tres breakers marcados con el nombre de "MOTOMAN".
<p align="center">
  <img src="https://github.com/user-attachments/assets/07030f27-3acd-4a4a-b286-cd1c193e0992" width="40%">
  <br>
  <em>Tomado de video explicativo.</em>
</p>

2. Energizamos el totalizador que se encuentra en el cofre totalizador. 
<p align="center">
<img src="https://github.com/user-attachments/assets/e6b5eabe-85ad-43c1-97e3-77457f9b95f9" width="40%" />
  <br>
  <em>Tomado de video explicativo.</em>
</p>

3. Giramos la perilla en la puerta del controlador para energizar la unidad de control DX100.
<p align="center">
<img src="https://github.com/user-attachments/assets/03ebd177-d8b0-416b-a9ad-fe63b538c6ed"  width="30%" />
  <br>
  <em>Tomado de <a href="https://people.wallawalla.edu/~ralph.stirling/classes/engr480/docs/Motoman/dx100_155494-1CD.pdf">Manual DX100</a>.</em>
</p>

4. Desenrollamos el cable del TeachPendant, cuidando no pisarlo, lo pasamos por detrás del cuello tal como lo indica el monitor.

5. En el TeachPendant, se gira el hongo (Emergency stop button) en sentido horario, quitando así la parada de emergencia. 

<p align="center">
<img src="https://github.com/user-attachments/assets/85b7f7c7-3f2f-40e7-a099-97ad934a6730"   width="30%" />
  <br>
  <em>Tomado de <a href="https://people.wallawalla.edu/~ralph.stirling/classes/engr480/docs/Motoman/dx100_155494-1CD.pdf">Manual DX100</a>.</em>
</p>

6. Con el selector de modo (Mode Switch) y la llave, se escoge el modo "teach".

<p align="center">
  <img src="https://github.com/user-attachments/assets/8592d4e3-1637-4092-9eae-c2d20834309d"  width="15%" />
  <br>
  <em>Tomado de: Presentación Fundamentos de Robótica industrial.</em>
</p>

7. En el menú del TeachPendant se escoge "robot".

8. Para habilitar el robot y permitir que reciba instrucciones y las ejecute habilitamos los servos con el botón "SERVO ON READY", la luz se encenderá cuando se presione el botón de hombre muerto.

<p align="center">
  <img src="https://github.com/user-attachments/assets/0e49e4a7-5620-4c24-9137-66a602f25998"  width="30%" />
  <br>
   <em>Tomado de <a href="https://people.wallawalla.edu/~ralph.stirling/classes/engr480/docs/Motoman/dx100_155494-1CD.pdf">Manual DX100</a>.</em>
</p>

<p align="center">
  <img src="https://github.com/user-attachments/assets/f5d66ac8-ff94-4257-8998-dfa2eb2c1c0e"  width="30%" />
  <br>
   <em>Tomado de <a   href="https://people.wallawalla.edu/~ralph.stirling/classes/engr480/docs/Motoman/dx100_155494-1CD.pdf">Manual DX100</a>.</em>
</p>

9. Seleccionamos la velocidad FAST o SLOW para el modo manual. El nivel de velocidad escogido corresponderá al icono que se observa en la parte superior de la pantalla:

<p align="center">
  <img   src="https://github.com/user-attachments/assets/1c62ef8a-cea3-43ca-98ae-e4cc6c85b928" width="30%" />
  <br>
   <em>Tomado de: Presentación Fundamentos de Robótica industrial.</em>
</p>


10. El botón para la selección de modo de movimiento es el botón COORD, según el modo de movimiento, se verá en la parte superior de la pantalla uno de los siguientes iconos:

<p align="center">
  <img src="https://github.com/user-attachments/assets/f0095fd0-997c-4e9f-beda-3a63c37f9b3e" width="30%" />
  <br>
   <em>Tomado de: Presentación Fundamentos de Robótica industrial.</em>
</p>

11. En el modo de movimiento en el espacio de las articulaciones se verá este icono en la parte superior de la pantalla:

<p align="center">
  <img src="https://github.com/user-attachments/assets/78c3c575-b0a0-4f70-9aca-faf013e8af63" width="20%" />
  <br>
   <em>Tomado de: Presentación Fundamentos de Robótica industrial.</em>
</p>

Los botones correspondientes a cada articulación se observan a continuación, donde los botones con la letra X Y o Z corresponderán al modo movimiento en el espacio de trabajo, mientras que S L U R B o T corresponderán al movimiento en el espacio de articulación:


<p align="center">
  <img src="https://github.com/user-attachments/assets/f8318fa4-3f7a-4e89-849d-83f7369c755f" width="20%" />
  <br>
   <em>Tomado de: Presentación Fundamentos de Robótica industrial.</em>
</p>

12. Si se trata del modo de movimiento en el espacio de trabajo se verá este icono en la parte superior de la pantalla:

<p align="center">
  <img alt="Pasted image 20251021203435" src="https://github.com/user-attachments/assets/adc2ae86-152d-4406-b958-cc27bf91c2bd"   width="20%" />
  <br>
   <em>Tomado de: Presentación Fundamentos de Robótica industrial.</em>
</p>





## Niveles de velocidad para enseñanza y cómo identificarlos en interfaz


**Conceptos.**
- **Jog speed (Teach):** velocidad manual al mantener pulsada la tecla. Suele tener niveles/fine-tuning.
- **Override de reproducción (Play):** porcentaje que escala velocidades de programa cuando “corres” un Job.

**Guía práctica en controladores Motoman (DX100/DX200/YRC1000, nomenclatura típica):**
- **TEACH/JOG:** niveles **Lento / Medio / Rápido** (o “Fine/Coarse”) con ajuste incremental. Usa **Lento (1–20 mm/s)** en proximidad de interferencias; **Medio (20–150 mm/s)** para desplazamientos libres; **Rápido (150–300+ mm/s)** solo en aire y con visibilidad.
- **PLAY:** **Speed Override** en % (p. ej., 5–100%). Para primeras pruebas, inicia en **5–10%** y sube gradualmente.
- **Indicadores en el HMI/Pendant:**
  - Barra de estado con **sistema de coordenadas activo** (BASE/USER/TOOL), **modo JOG** (JNT/XYZ/RxRyRz), y **velocidad** visible como **Teach Speed** o **Override %**.
  - Iconos/teclas dedicadas para cambiar **Fine/Coarse** y **SPEED OVERRIDE**. Verifica que el **servo ON** esté habilitado y que **REMOTE/LOCAL** sea coherente con tu procedimiento.
- **Criterio de aceptación para enseñanza:**
  1) Ningún eje supera límites ni zonas definidas de seguridad.
  2) En targets de precisión, captura con **Teach Speed baja** y **rotaciones Rx/Ry/Rz finas**.
  3) Repite el movimiento con **Override bajo** y confirma tiempos y clearances.

### Seleccion de velocidad de forma fisica en el Tech Pendant.
En la imagen continua se muestra cuales son los botones para seleccionar la velocidad de forma manual en el Tech Pendant.

<p align="center">
  <img width="500" alt="Diagrama" src="https://github.com/user-attachments/assets/4fe46496-607e-4f75-b090-1ae7c6a1f65d" />
</p>



## Funcionalidades de RoboDK y método de comunicación con Motoman (con Python)

**Capacidades relevantes de RoboDK para esta célula:**
- **Programación offline (OLP)** multi‑marca: definición de marcos, herramientas, detección de colisiones, generación de trayectorias sobre superficies.
- **APIs** (Python/C#/C++/Matlab/Java) para automatizar importaciones CAD, cálculo de poses y post‑procesado a código de robot.
- **Drivers online**: conexión directa por Ethernet a controladores soportados para ejecutar movimientos desde la simulación (jog/MoveJ/MoveL) y verificar I/O básicas.
- **Postprocesadores Motoman**: exportación de **Jobs .JBI** listos para cargar por **USB/FTP** en el controlador.

**Formas de conexión Motoman ↔ RoboDK:**
1. **Online (Driver de RoboDK, Ethernet).**
   - Requisitos: IP del controlador, robot en **REMOTE**, permisos habilitados, servo listo. En RoboDK: clic derecho sobre el robot → **Conectar al robot** → configura IP → **Conectar**.
   - Ventaja: pruebas inmediatas de trayectorias, verificación de frames y TCP en vivo.
2. **Offline + Transferencia de programas (.JBI).**
   - En RoboDK: **Program → Generate Program** usando el postprocesador Motoman. Transfiere por **USB** o **FTP** al controlador y ejecuta desde el pendant.
   - Ventaja: no requiere enlace en vivo; ideal para entornos sin red industrial abierta.
3. **API externa → RoboDK → Robot.**
   - Un script externo en Python controla RoboDK vía API; RoboDK, a su vez, maneja el robot por driver o genera .JBI. Útil para flujos de **automatización** e integración con software de proceso.

**Dónde y cómo pegar código Python en RoboDK:**
- Opción A: en RoboDK, **Station → Add → Python Program**. Abre el editor integrado, pega el script y ejecuta con el botón **Run**.
- Opción B: **Tools → Run Script** y selecciona tu `.py`.
- Opción C (externo): instala `robodk` (`pip install robodk`), mantén RoboDK abierto y ejecuta tu script desde la terminal/IDE. El script se conecta a la instancia activa de RoboDK.

**Ejemplo de script (conexión, selección de robot, frames y figura “rosa polar”)**

> Este script fue proporcionado por los docentes de la asignatura como ejemplo de aprendizaje, en el se asume que ya configuraste la IP del robot en el ítem de robot dentro de RoboDK y que el controlador está en **REMOTE**. El flujo es: API Python → RoboDK → Driver Motoman → Robot.

```python
from robodk.robolink import *    # API para RoboDK
from robodk.robomath import *    # Funciones matemáticas
import math

# 1) Abrir conexión con RoboDK e inicializar
RDK = Robolink()

# Elegir un robot (si hay varios)
robot = RDK.ItemUserPick("Selecciona un robot", ITEM_TYPE_ROBOT)
if not robot.Valid():
    raise Exception("No se ha seleccionado un robot válido.")

# 2) Conexión online al robot físico (IP configurada en el ítem del robot)
print("Conectando al robot...")
if not robot.Connect():
    raise Exception("No se pudo conectar. Verifica REMOTE en el controlador, IP/puerto y permisos.")

if not robot.ConnectedState():
    raise Exception("Conexión no establecida. Revisa el driver y la red.")

print("Robot conectado correctamente.")

# 3) Selección de frame y herramienta
frame_name = "Frame_from_Target1"   # Ajusta el nombre al de tu estación
frame = RDK.Item(frame_name, ITEM_TYPE_FRAME)
if not frame.Valid():
    raise Exception(f'No se encontró el Frame "{frame_name}".')

robot.setPoseFrame(frame)           # Trabajar en el marco seleccionado
robot.setPoseTool(robot.PoseTool()) # Usa la herramienta activa

# 4) Parámetros de velocidad y suavizado
robot.setSpeed(300)   # mm/s (enseñanza/validación; ajusta según tu política)
robot.setRounding(5)  # mm de blend (0 para esquinas agudas)

# 5) Parámetros de la rosa polar r = A*sin(k*θ)
num_points = 720
A = 150          # mm
k = 5            # pétalos (si k impar → k pétalos; si par → 2k)
z_surface = 0    # Plano de trabajo Z=0 del frame
z_safe = 50      # Altura segura

# 6) Aproximación al centro en altura segura
robot.MoveJ(transl(0, 0, z_surface + z_safe))
robot.MoveL(transl(0, 0, z_surface))

# 7) Trazado de la figura
full_turn = 2*math.pi
for i in range(num_points + 1):
    t = i / num_points
    theta = full_turn * t
    r = A * math.sin(k * theta)
    x = r * math.cos(theta)
    y = r * math.sin(theta)
    robot.MoveL(transl(x, y, z_surface))

# 8) Salida segura
robot.MoveL(transl(x, y, z_surface + z_safe))
print(f"Figura completada en el frame '{frame_name}'.")
```

**Notas operativas y variantes de conexión:**
- **Driver configurado en el ítem del robot:** clic derecho sobre el robot en RoboDK → **Conectar al robot** → define **IP/puerto**. El script `robot.Connect()` reutiliza esa configuración.
- **Solo offline:** omite `robot.Connect()` y usa RoboDK para **generar .JBI**; transfiere por USB/FTP.
- **Pruebas sin hardware:** si no hay controlador, el script simula sobre el modelo de RoboDK; valida colisiones y alcance, luego exporta a .JBI.
- **Seguridad:** activa límites, zonas y reduce `setSpeed` y `setRounding` durante primeras pruebas. Nunca ejecutes online sin barreras y sin consenso del equipo de seguridad.

---

## 🧩 RoboDK: aplicaciones y comunicación con el robot

- **Aplicaciones**: simulación 3D, programación offline, generación de código, post‑procesadores, detección de colisiones, calibración, drivers online.  
- **Comunicación (online)** con Motoman:  
  1) En RoboDK: **Connect → Connect Robot**.  
  2) Configurar **IP/puerto** del controlador (DX100/DX200).  
  3) **Seleccionar driver** Motoman y **probar ping**.  
  4) **Sincronizar**: mover en simulación y ejecutar en robot (online).  
  5) Alternativa **offline**: **Generate Program** → exportar INFORM y cargar al controlador.

---

## 🆚 RoboDK vs RobotStudio
<p align="center">
   <img width="200" alt="Robodk" src="https://github.com/user-attachments/assets/b88f16c8-7c25-4e7e-9710-28e4feb8e91f" />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  
  <img width="300" height="350" alt="Abb" src="https://github.com/user-attachments/assets/a3818a72-491e-48e0-b395-98417e7148f2" />
</p>




Propósito
---------
Comparar con criterio de ingeniería dos ecosistemas de programación y simulación de robots industriales: RoboDK (multimarca) y RobotStudio (ABB). El objetivo es orientar decisiones de selección, planeación de celdas y preparación de procesos (OLP, commissioning y soporte en planta).

1) Arquitectura y fidelidad de simulación
-----------------------------------------
• RoboDK
  - Motor cinemático propio y modelos de robots de múltiples fabricantes. 
  - Foco en Programación Offline (OLP), postprocesadores por marca/controlador y drivers “online” para pruebas en tiempo real.
  - Fidelidad “control‑agnostic”: muy buena para cinemática, envolventes, colisiones y orientación herramienta; la exactitud temporal y de microcomandos depende del postprocesado y del driver.
• RobotStudio (ABB)
  - Incluye Virtual Controller (VC) con firmware de ABB (RobotWare). Emula RAPID, planificador de movimiento, parámetros del sistema y FlexPendant virtual.
  - Fidelidad alta para robots ABB: tiempos de ciclo, zonas de blend, eventos, E/S lógicas y MultiMove se comportan casi 1:1 respecto a la celda real.
Implicación práctica: si tu célula es 100% ABB y necesitas pre‑comisionar con máxima fidelidad, RobotStudio domina. Si trabajas con marcas mixtas o cambias de robot a menudo, RoboDK ofrece mayor versatilidad.

2) Lenguajes, programación y APIs
---------------------------------
• RoboDK
  - Scripting/API: Python, C#, C++, Matlab, Java. Automatización de importación CAD/CAM, generación de trayectorias, cálculo de poses, simulación y exportación.
  - Postprocesadores: genera código específico (p.ej., RAPID, KRL, TP, JBI, INFORM, etc.) ajustable a estándares de planta.
  - Macros para rutinas de calibración, cambio de herramienta, “Machining” 3‑5 ejes, pick&place y lógica de celda básica.
• RobotStudio (ABB)
  - Programación nativa en RAPID, módulos y tareas del sistema; edición con IntelliSense, depuración y ejecución paso a paso sobre el VC.
  - FlexPendant virtual y herramientas para Smart Components, Path Editor, MultiMove, SafeMove (configuración), I/O simuladas y captura de eventos.
  - SDK y complementos especializados (PowerPacs) para soldadura, mecanizado, machine tending, paletizado, etc.
Resumen: RoboDK destaca por la orquestación programática y el soporte multi‑lenguaje; RobotStudio por el ecosistema RAPID y el ciclo de vida completo ABB (desde diseño a mantenimiento).

3) Soporte de marcas y ecosistema
---------------------------------
• RoboDK: librería amplia de robots, controladores y herramientas de múltiples fabricantes. Ideal para integradores, universidades y celdas donde cambian marcas o modelos.
• RobotStudio: centrado en ABB con integración profunda a características de controlador (MultiMove, EGM, SafeMove, LoadIdentify, etc.).

4) Trayectorias, superficies y procesos
--------------------------------------
• RoboDK
  - Importa CAD/CAM (STEP/IGES/DXF, etc.) y genera trayectorias “path‑on‑surface”, tool orientation controlada, offsets y blends.
  - Plugins de mecanizado 3‑5 ejes y utilidades para evitar singularidades, límites articulares y colisiones.
• RobotStudio
  - Path Editor avanzado, creación de targets sobre geometría, ajuste fino de zonas y velocidades reales del controlador.
  - PowerPacs específicos por proceso (soldadura, corte, lijado, paletizado) con plantillas de mejores prácticas ABB.
Conclusión: ambos resuelven “path sobre superficie”; RobotStudio ofrece ajuste fino con semántica del controlador ABB; RoboDK es flexible para múltiples marcas y CAM‑like workflows.

5) Online, I/O y pre‑comisionamiento
------------------------------------
• RoboDK
  - Drivers online para ejecutar y testear en robots reales de varias marcas; utilidad para verificación de poses, orientaciones e I/O simples.
  - La lógica compleja de célula suele residir en PLC/robot y se valida en campo.
• RobotStudio
  - Virtual Controller con E/S lógicas, tareas, eventos y emulación de FlexPendant. Permite probar secuencias, handshakes y MultiMove antes del hardware.
Moraleja: para “dry‑run” de una célula ABB, RobotStudio reduce horas de puesta en marcha. Para verificación general y prototipos multi‑marca, RoboDK es rápido y suficiente.

6) Calibración y precisión
--------------------------
• RoboDK: herramientas para identificar TCP, base, calib. de herramienta y celda; mejora repetibilidad de OLP con medición externa cuando está disponible.
• RobotStudio (ABB): flujo nativo con utilidades ABB (p.ej., LoadIdentify, tuneo de trayectorias, definición exacta de cinemática y sistemas de coordenadas) y servicios de calibración de fabricante.
Idea clave: la precisión absoluta depende de la calibración mecánica y los parámetros reales del robot. RoboDK y RobotStudio soportan esos flujos en distinto grado; con ABB, RobotStudio capitaliza parámetros del propio controlador.

7) Integración con PLC/OT y datos
---------------------------------
• RoboDK: scripting y drivers para triggers, estados y E/S básicas; para fieldbuses y OPC UA suele considerarse la capa de PLC/controlador real.
• RobotStudio: simula E/S lógicas del sistema ABB. Para buses industriales, la verificación completa es en hardware, pero la lógica RAPID se depura en el VC.

8) Licenciamiento y costos (orientativo)
----------------------------------------
• RoboDK: coste inicial accesible, licencias perpetuas o suscripción, descuentos académicos, módulos adicionales (p.ej., machining).
• RobotStudio: versión base gratuita con limitaciones; licencias de VC y PowerPacs de costo corporativo; típicamente más alto que RoboDK, pero con retorno si la planta es ABB‑centrica.

9) Curva de aprendizaje y operación
-----------------------------------
• RoboDK: curva suave para OLP genérica, scripting claro y documentación práctica. Requiere entender postprocesadores por marca.
• RobotStudio: requiere familiaridad con RAPID y conceptos del sistema ABB. A cambio, ofrece depuración y análisis con fidelidad de controlador.

10) Casos de uso recomendados
-----------------------------
• Elige RoboDK cuando:
  - Tienes múltiples marcas de robot en la planta o en el laboratorio.
  - Tu foco es generar código y simular rápido, con APIs para automatizar y estandarizar OLP.
  - Necesitas integrar flujos CAD/CAM con cambios frecuentes de herramienta y orientación.
• Elige RobotStudio cuando:
  - La célula es ABB, requieres tiempos de ciclo realistas, MultiMove, SafeMove y pruebas de lógica antes del hardware.
  - Quieres depurar RAPID, mapear I/O, validar zonas y hacer pre‑comisionamiento en alto detalle.

11) Matriz de decisión rápida
-----------------------------
• ¿Ecosistema?: Multi‑marca → RoboDK | Solo ABB → RobotStudio.
• ¿Fidelidad de controlador y tiempos de ciclo?: Alta prioridad → RobotStudio | Media → RoboDK.
• ¿Budget inicial?: Bajo/medio → RoboDK | Medio/alto corporativo → RobotStudio.
• ¿Automatización por scripting multi‑lenguaje?: RoboDK sobresale.
• ¿RAPID y Virtual Controller con FlexPendant?: RobotStudio.

12) Buenas prácticas (aplican a ambos)
--------------------------------------
1. Calibra TCP y bases; usa fixtures de referencia.
2. Mantén una librería controlada de postprocesadores y plantillas por célula.
3. Define tolerancias de orientación y blending realistas; valida singularidades.
4. Versiona estaciones/proyectos y congela parámetros antes de comisionar.
5. Ejecuta pilotos en vacío y dry‑runs con límites de seguridad conservadores.
6. Documenta offsets, sistemas de coordenadas y cambios de herramienta en un único “dossier de celda”.

13) Limitaciones y riesgos frecuentes
-------------------------------------
• Diferencias entre simulación y planta por fricción, carga real, flexibilidad y holguras.
• Captura parcial de lógicas de seguridad y fieldbuses complejos en simulación.
• Exceso de confianza en tiempos de ciclo sin considerar periféricos y PLC.
• Postprocesadores desalineados con convenciones de fábrica → retrabajo en piso.

Conclusión
----------
RoboDK maximiza versatilidad y automatización multi‑marca con OLP ágil y APIs potentes. RobotStudio maximiza fidelidad y productividad dentro del universo ABB al ofrecer un gemelo virtual de alto detalle. La elección racional depende de tu ecosistema, del nivel de realismo requerido antes de tocar hardware y del presupuesto total de la célula.


---

# 🧭 Trayectoria polar y Nombres en RoboDK 
## Flujograma de las trayectorias 
Se presenta el diagrama de flujo del proceso desarrollado para garantizar el cumplimiento de los requerimientos del proyecto.

<p align="center">
  <img width="300" height="1800" alt="Diagrama" src="https://github.com/user-attachments/assets/b4754bc3-e62c-48e4-bc11-7b8817980d58" />
</p>

## Plano de planta 
Se muestra el plano de planta del ecosistema de trabajo en RoboDK.
<p align="center">
  <img width="800" alt="Diagrama" src="https://github.com/user-attachments/assets/16f26b22-483d-4d7d-af32-d7808ffc726a" />
</p>


#### Plano lateral
Como visualizacion auxiliar se muestra un plano lateral del ecossistema en RoboDK, para tener mejor entendimiento de las posciones de cada elemento.

<p align="center">   
  <img width="397" height="2300" alt="Diagrama" src="https://github.com/user-attachments/assets/b1316eda-23ef-4b55-97e4-69671ab84608" />
</p>

## Codigo Python de trayectorias 
A continuacion se presenta el codigo que se desarrollo para realizar las trayectorias de lo nombres de integrantes y figura en forma polar.
```python
from robodk.robolink import *    # API para comunicarte con RoboDK
from robodk.robomath import *    # Funciones matemáticas
import math

#------------------------------------------------
# 1) Conexión a RoboDK e inicialización
#------------------------------------------------
RDK = Robolink()

# Elegir un robot 
robot = RDK.ItemUserPick("Selecciona un robot", ITEM_TYPE_ROBOT)
if not robot.Valid():
    raise Exception("No se ha seleccionado un robot válido.")

# Conectar al robot físico
#if not robot.Connect():
#    raise Exception("No se pudo conectar al robot. Verifica que esté en modo remoto y que la configuración sea correcta.")

# Confirmar conexión
#if not robot.ConnectedState():
#    raise Exception("El robot no está conectado correctamente. Revisa la conexión.")

#print("Robot conectado correctamente.")

#------------------------------------------------
# 2) Cargar el Frame  donde quieres dibujar
#------------------------------------------------
frame_name = "Frame_from_Target1"
frame = RDK.Item(frame_name, ITEM_TYPE_FRAME)
if not frame.Valid():
    raise Exception(f'No se encontró el Frame "{frame_name}" en la estación.')

# Asignamos este frame al robot
robot.setPoseFrame(frame)
# Usamos la herramienta activa
robot.setPoseTool(robot.PoseTool())

# Ajustes de velocidad y blending
robot.setSpeed(300)   # mm/s - Ajusta según necesites
robot.setRounding(5)  # blending (radio de curvatura)

robot.Pause(2)  # Espera 2 segundos

robot.MoveJ([0, 0, 0, 0, 0, 0])

#------------------------------------------------
# 3) Definiciones de letras y parámetros de escritura
#------------------------------------------------

# Letras definidas en matriz 3x3
letras = {
    'C': [[2,2],[0,2],[0,0],[2,0]],
    'A': [[0,0],[1,2],[2,0]],
    'M': [[0,0],[0,2],[1,1],[2,2],[2,0]],
    'N': [[0,0],[0,2],[2,0],[2,2]],
    'I': [[1,0],[1,2]],
    'O': [[0,0],[2,0],[2,2],[0,2],[0,0]],
    'G': [[2,2],[0,2],[0,0],[2,0],[2,1],[0,1]],
    'B': [[0,0],[0,2],[2,2],[2,1],[0,1],[2,1],[2,0],[0,0]],
}

# Lista de nombres a escribir
nombres = ["cami", "gabo", "nico"]

# Parámetros de dibujo
escala = 30             # tamaño de cada paso en mm
espacio_letra = 70      # espacio entre letras
espacio_linea = 70      # espacio entre líneas
z_surface = 0           # altura para escribir
z_safe = -50             # altura segura

#------------------------------------------------
# 4) Función para mover el robot a dibujar una letra
#------------------------------------------------
def dibujar_letra(letra_coords, offset_x, offset_y):
    first = True
    last_pose = None  # Guardaremos la última posición
    
    for punto in letra_coords:
        x = offset_x + punto[0] * escala
        y = offset_y + (2 - punto[1]) * escala  # invierte eje Y

        pose = transl(x, y, z_surface)
        pose_arriba = transl(x, y, z_surface + z_safe)

        if first:
            robot.MoveJ(pose_arriba)
            robot.MoveL(pose)
            first = False
        else:
            robot.MoveL(pose)
        
        last_pose = pose  # Actualizamos última posición
    
    robot.MoveL(transl(last_pose[0,3], last_pose[1,3], z_surface + z_safe))

    return last_pose


#------------------------------------------------
# 5) Escribir los nombres letra por letra
#------------------------------------------------

# Escribir nombres en horizontal, uno por línea
ultima_pos = None

for row_index, nombre in enumerate(nombres):
    for col_index, letra in enumerate(nombre.upper()):
        if letra not in letras:
            continue

        offset_x = col_index * espacio_letra - 50  # ajustes
        offset_y = -row_index * espacio_linea

        ultima_pos = dibujar_letra(letras[letra], offset_x, offset_y)

print("¡Nombres escritos con éxito!")

# Finalmente, subir en Z seguro desde la última posición
#if ultima_pos is not None:
#    x = ultima_pos[0,3]
#    y = ultima_pos[1,3]
#    robot.MoveL(transl(x, y, z_surface + z_safe))



#------------------------------------------------
# 6) Parámetros de la figura (rosa polar)
#------------------------------------------------
num_points = 50       # Cuántos puntos muestreamos (mayor = más suave)
A = 50               # Amplitud (300 mm = radio máximo)
k = 5                  # Parámetro de la rosa (pétalos). Si es impar, habrá k pétalos; si es par, 2k
z_surface = 0          # Z=0 en el plano del frame
z_safe = -50            # Altura segura para aproximarse y salir

#------------------------------------------------
# 7) Movimiento al centro en altura segura
#------------------------------------------------
# El centro de la rosa (r=0) corresponde a x=0, y=0
robot.MoveJ(transl(0, 0, z_surface + z_safe))

# Bajamos a la "superficie" (Z=0)
robot.MoveL(transl(0, 0, z_surface))

#------------------------------------------------
# 8) Dibujar la rosa polar
#    r = A * sin(k*theta)
#    x = r*cos(theta), y = r*sin(theta)
#------------------------------------------------
# Recorremos theta de 0 a 2*pi (una vuelta completa)
full_turn = 2*math.pi

for i in range(num_points+1):
    # Fracción entre 0 y 1
    t = i / num_points
    
    # Ángulo actual
    theta = full_turn * t

    # Calculamos r
    r = A * (2 + math.sin(4 * theta))

    # Convertimos a coordenadas Cartesianas X, Y
    x = r * math.cos(theta) + 375
    y = r * math.sin(theta) 

    # Movemos linealmente (MoveL) en el plano del Frame
    robot.MoveL(transl(x, y, z_surface))

# Al terminar, subimos de nuevo para no chocar
robot.MoveL(transl(x, y, z_surface + z_safe))

print(f"¡Figura (rosa polar) completada en el frame '{frame_name}'!")


robot.Pause(2)  # Espera 2 segundos

robot.MoveJ([0,0,0,0,0,0])
```
### Trayectoriaas realizadas
En color naranja se muestran los "dibujos" solicitados para el proyecto.
<p align="center">
  <img width="800" alt="Diagrama" src="https://github.com/user-attachments/assets/6e9e78b0-2a3d-4f59-944b-76bb66e2fcb5" />
</p>

## Simulacion de RoboDK
La simulacion de las trayectorias realizados con el codigo previamente mostrado se presenta mediante un video.

## Implementacion en Motoman MH6
La implementacion de las trayectorias realizados en la simulacion previamente mostrado se presenta mediante un video.






---

