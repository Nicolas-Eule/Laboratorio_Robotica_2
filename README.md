![Robodk](https://github.com/user-attachments/assets/22d2c19c-e174-446e-b82c-8880e2228238)<!-- ‚ú¶‚ú¶‚ú¶ FUTURE IS AUTOMATED ‚ú¶‚ú¶‚ú¶ -->
<!-- Banner superior ‚Äúne√≥n‚Äù -->
<p align="center">
  <!-- El banner se genera usando capsule-render con colores adaptados al Laboratorio¬†2 -->
  <img src="https://capsule-render.vercel.app/api?type=waving&height=140&color=0:04041A,50:14213D,100:0A4D68&text=Laboratorio%20Rob%C3%B3tica%202&fontColor=E0FBFC&fontAlign=50&fontAlignY=30&desc=An%C3%A1lisis%20y%20Operaci%C3%B3n%20del%20Manipulador%20Motoman%20MH6&descAlign=50&descAlignY=60" alt="header" />
</p>

<h1 align="center">ü§ñ LABORATORIO¬†ROB√ìTICA¬†2 ‚Äì AN√ÅLISIS Y OPERACI√ìN DEL MANIPULADOR MOTOMAN¬†MH6</h1>

<p align="center">
  <img src="https://img.shields.io/badge/RoboDK-Simulation-green?style=for-the-badge" />
  <img src="https://img.shields.io/badge/Motoman-MH6-blue?style=for-the-badge" />
  <img src="https://img.shields.io/badge/Industrial-Robotics-orange?style=for-the-badge" />
</p>

<!-- L√≠nea de texto mecanografiado (animado) -->
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&weight=700&size=20&pause=1500&duration=3500&color=00E5FF&center=true&vCenter=true&width=900&lines=Rob%C3%B3tica+Industrial+2025%E2%80%93II;Motoman+MH6+%E2%80%A2+RoboDK+%E2%80%A2+RobotStudio;Comparaci%C3%B3n+de+manipuladores+y+trayectoria+polar" alt="typing" />
</p>

---

### üõ∞Ô∏è Descripci√≥n general

Este repositorio implementa el **Laboratorio¬†No.¬†2** de *Rob√≥tica Industrial 2025‚ÄëII*: **an√°lisis y operaci√≥n del manipulador Motoman¬†MH6**, comparaci√≥n con **ABB¬†IRB140**, pr√°ctica de **movimientos manuales**, **cambio de velocidades**, y **programaci√≥n/ejecuci√≥n de una trayectoria polar** en **RoboDK** con demostraci√≥n virtual y **ejecuci√≥n f√≠sica** del Motoman desde el PC.

---

## üéØ Resultados de aprendizaje
- Comparar caracter√≠sticas t√©cnicas entre **Motoman¬†MH6** y **ABB¬†IRB140**.
- Identificar y describir **home1** y **home2** del Motoman¬†MH6.
- Realizar **movimientos manuales** en modos articular/cartesiano (traslaci√≥n y rotaci√≥n).
- Configurar y cambiar **niveles de velocidad** para ense√±anza.
- Explicar **aplicaciones de RoboDK** y su **comunicaci√≥n** con el manipulador.
- Analizar diferencias **RoboDK vs RobotStudio**.
- Dise√±ar, simular y ejecutar **trayectoria polar**; registrar evidencia en video.

---

## üßë‚ÄçüöÄ Equipo
<!-- ===== INICIO BLOQUE ANIMACIONES EQUIPO (una animaci√≥n por l√≠nea) ===== -->

<!-- Encabezado: Integrantes -->
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&weight=800&size=22&duration=2000&pause=1800&color=00E5FF&center=true&vCenter=true&width=1000&repeat=true&v=1&lines=Integrantes%3A" alt="Integrantes">
</p>

<!-- Nombre 1 -->
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&weight=700&size=20&duration=2400&pause=2000&color=7F5AF0&center=true&vCenter=true&width=1000&repeat=true&v=1&lines=Jorge+Nicol%C3%A1s+Garz%C3%B3n+Acevedo+%E2%80%94+jngarzona%40unal.du.co" alt="Jorge Nicol√°s Garz√≥n Acevedo">
</p>

<!-- Nombre 2 -->
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&weight=700&size=20&duration=2400&pause=2000&color=7F5AF0&center=true&vCenter=true&width=1000&repeat=true&v=1&lines=Johan+Camilo+Pati%C3%B1o+Mogoll%C3%B3n+%E2%80%94+jopatinom%40unal.edu.co" alt="Johan Camilo Pati√±o Mogoll√≥n">
</p>

<!-- Nombre 3 -->
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&weight=700&size=20&duration=2400&pause=2000&color=7F5AF0&center=true&vCenter=true&width=1000&repeat=true&v=1&lines=Gabriel+Eduardo+Bojaca+Munar+%E2%80%94+gbojaca%40unal.edu.co" alt="Gabriel Eduardo Bojaca Munar">
</p>

<!-- Encabezado: Docentes -->
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&weight=1800&size=22&duration=2000&pause=1800&color=00E5FF&center=true&vCenter=true&width=1000&repeat=true&v=1&lines=Docentes%3A" alt="Docentes">
</p>

<!-- Docente 1 -->
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&weight=700&size=20&duration=2400&pause=2000&color=39D353&center=true&vCenter=true&width=1000&repeat=true&v=1&lines=Manuel+Felipe+Carranza+Montenegro+%E2%80%94+mcarranza%40unal.edu.co" alt="Manuel Felipe Carranza Montenegro">
</p>

<!-- Docente 2 -->
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&weight=700&size=20&duration=2400&pause=2000&color=39D353&center=true&vCenter=true&width=1000&repeat=true&v=1&lines=Pedro+Fabi%C3%A1n+C%C3%A1rdenas+Herrera+%E2%80%94+pfcardenash%40unal.edu.co" alt="Pedro Fabi√°n C√°rdenas Herrera">
</p>

<!-- ===== FIN BLOQUE ANIMACIONES EQUIPO ===== -->

## üìä Cuadro comparativo (MH6 vs IRB140)

| Caracter√≠stica | Motoman MH6 | ABB IRB140 |
|---|---|---|
| **Fabricante** | YASKAWA | ABB |
| **Controlador** | DX100 | IRC5 con RobotWare |
| **Estructura** | Robot articulado | Robot articulado |
| **DOF** | 6 (8 con riel suelo + eje adicional) | 6 |
| **Payload [kg]** | 6 | 6 |
| **Radio de trabajo [mm]** | 1422 | 800 |
| **Repetibilidad [mm]** | ¬±0,08 | ¬±0,03 |
| **Peso del manipulador [kg]** | 130 | 98 |
| **Montajes permitidos** | Suelo ‚Ä¢ Muro ‚Ä¢ Suspendido | Suelo ‚Ä¢ Muro ‚Ä¢ Suspendido |
| **Movimiento angular S:1** | ¬±170¬∞ | ¬±180¬∞ |
| **Movimiento angular L:2** | +155¬∞/‚Äì90¬∞ | +110¬∞/‚Äì90¬∞ |
| **Movimiento angular U:3** | +250¬∞/‚Äì175¬∞ | +50¬∞/‚Äì230¬∞ |
| **Movimiento angular R:4** | ¬±180¬∞ | ¬±200¬∞ (hasta ¬±165 rev) |
| **Movimiento angular B:5** | +225¬∞/‚Äì45¬∞ | ¬±115¬∞ |
| **Movimiento angular T:6** | ¬±360¬∞ | ¬±400¬∞ (hasta ¬±163 rev) |
| **Velocidad m√°x. S:1 (¬∞/s)** | 220 | 200 |
| **Velocidad m√°x. L:2 (¬∞/s)** | 200 | 200 |
| **Velocidad m√°x. U:3 (¬∞/s)** | 220 | 260 |
| **Velocidad m√°x. R:4 (¬∞/s)** | 410 | 360 |
| **Velocidad m√°x. B:5 (¬∞/s)** | 410 | 360 |
| **Velocidad m√°x. T:6 (¬∞/s)** | 610 | 450 |
| **Aceleraci√≥n m√°x. TCP** | ‚Äî | 57 m/s¬≤ (movimiento controlado) |
| **Nivel de protecci√≥n (IP)** | ‚Äî | IP67 (hasta mu√±eca) |
| **Temperatura de operaci√≥n [¬∞C]** | 0 a +45 | +5 a +45 |
| **Humedad relativa de operaci√≥n [%]** | 20‚Äì80 | ‚â§95 (sin condensaci√≥n) |
| **Consumo de potencia** | 1,5 kVA (promedio) | 0,44 kW a 1000 mm/s |
| **Aplicaciones t√≠picas** | Manipulaci√≥n, alimentaci√≥n de m√°quinas, ensamblaje, soldadura, dispensado, empaquetado | Manejo de materiales, ensamblaje, fundici√≥n (Foundry Plus 2), clean room, soldadura, pegado |

---

## üè† Home1 vs Home2 (Motoman¬†MH6)

- **home1**: postura base/neutral de referencia (U horizontal, R vertical). Facilita la **referencia de inicio** y verificaciones r√°pidas. Minimiza los torques sobre las articulaciones, permitiendo alargar la vida util de los frenos el√©ctricos. Usada para embalaje. 
  ![Home 1](https://github.com/user-attachments/assets/e92957dd-9720-4434-ab57-77ba89957654)

- **home2**: postura elevada/retra√≠da para **mantenimiento/cambio de herramienta** y tr√°nsito seguro.
 ![Home 2](https://github.com/user-attachments/assets/6b8ff6a6-8e50-4fdd-bf1b-c4c8c9c53c44)

- **Elecci√≥n**: usar **home1** para inicio/fin de ciclo y **home2** como aparcamiento/mantenimiento; justificar seg√∫n layout y seguridad.

---

## Procedimiento detallado de movimientos manuales (articular ‚Üî cartesiano; traslaciones/rotaciones X‚ÄëY‚ÄëZ)

**Objetivo.** Ejecutar ense√±anza segura y precisa, dominando cambio de modos de jog, selecci√≥n de marcos y ejes cartesianos/angulares.

**Secuencia recomendada (Teach Pendant):**
1. **Estado seguro.**
   - Robot en Teach, √°rea despejada, paro de emergencia probado, servo OFF.
   - Selecciona herramienta correcta (TCP) y sistema de coordenadas base/celda.
2. **Modo de jog.**
   - **Articular (JOINT/JOG J1‚Ä¶J6):** cada tecla mueve un eje. √ötil para desenganchar singularidades, plegar/desplegar y aproximaciones gruesas.
   - **Cartesiano (XYZ / Rx Ry Rz):**
     - **Traslaciones:** X, Y, Z del marco activo (BASE, USER/FRAME, o TOOL).
     - **Rotaciones:** Rx, Ry, Rz son rotaciones alrededor de los ejes X, Y, Z del marco activo.
   - Cambia entre **BASE/USER/TOOL** seg√∫n necesites: BASE para desplazamientos globales, USER/FRAME para trayectorias en dispositivos, TOOL para orientar la herramienta sin modificar posici√≥n del TCP.
3. **Transici√≥n articular ‚Üí cartesiano.**
   - Desplaza en articular hasta una postura sin riesgos (evitar toques mec√°nicos y l√≠mites).
   - Pasa a cartesiano y **ac√©rcate en Z** del marco de trabajo, luego corrige en X/Y y finalmente afina orientaci√≥n con Rx/Ry/Rz.
4. **Transici√≥n cartesiano ‚Üí articular.**
   - Cuando detectes cercan√≠a a singularidades (p. ej., mu√±eca con J5‚âà0¬∞), vuelve a articular para reorientar, y regresa a cartesiano.
5. **Buenas pr√°cticas.**
   - Trabajo cerca de pieza: prioriza **Z** para aproximar/retirar. Mant√©n **blend = 0** al ense√±ar puntos cr√≠ticos.
   - Guarda posiciones como **Targets** con nombres sem√°nticos (APROX_, PUNTO_, RETIRO_). Documenta marco y herramienta usados.
   - Comprueba l√≠mites articulares y de velocidad antes de ejecutar en AUTO.

**Proceso detallado de que procedicimento realiar en el Motoman MH6**
1. Energizamos los tres breakers marcados con el nombre de "MOTOMAN".
<p align="center">
  <img src="https://github.com/user-attachments/assets/07030f27-3acd-4a4a-b286-cd1c193e0992" width="40%">
  <br>
  <em>Tomado de video explicativo.</em>
</p>

2. Energizamos el totalizador que se encuentra en el cofre totalizador. 
<p align="center">
<img src="https://github.com/user-attachments/assets/e6b5eabe-85ad-43c1-97e3-77457f9b95f9" width="40%" />
  <br>
  <em>Tomado de video explicativo.</em>
</p>

3. Giramos la perilla en la puerta del controlador para energizar la unidad de control DX100.
<p align="center">
<img src="https://github.com/user-attachments/assets/03ebd177-d8b0-416b-a9ad-fe63b538c6ed"  width="30%" />
  <br>
  <em>Tomado de <a href="https://people.wallawalla.edu/~ralph.stirling/classes/engr480/docs/Motoman/dx100_155494-1CD.pdf">Manual DX100</a>.</em>
</p>

4. Desenrollamos el cable del TeachPendant, cuidando no pisarlo, lo pasamos por detr√°s del cuello tal como lo indica el monitor.

5. En el TeachPendant, se gira el hongo (Emergency stop button) en sentido horario, quitando as√≠ la parada de emergencia. 

<p align="center">
<img src="https://github.com/user-attachments/assets/85b7f7c7-3f2f-40e7-a099-97ad934a6730"   width="30%" />
  <br>
  <em>Tomado de <a href="https://people.wallawalla.edu/~ralph.stirling/classes/engr480/docs/Motoman/dx100_155494-1CD.pdf">Manual DX100</a>.</em>
</p>

6. Con el selector de modo (Mode Switch) y la llave, se escoge el modo "teach".

<p align="center">
  <img src="https://github.com/user-attachments/assets/8592d4e3-1637-4092-9eae-c2d20834309d"  width="15%" />
  <br>
  <em>Tomado de: Presentaci√≥n Fundamentos de Rob√≥tica industrial.</em>
</p>

7. En el men√∫ del TeachPendant se escoge "robot".

8. Para habilitar el robot y permitir que reciba instrucciones y las ejecute habilitamos los servos con el bot√≥n "SERVO ON READY", la luz se encender√° cuando se presione el bot√≥n de hombre muerto.

<p align="center">
  <img src="https://github.com/user-attachments/assets/0e49e4a7-5620-4c24-9137-66a602f25998"  width="30%" />
  <br>
   <em>Tomado de <a href="https://people.wallawalla.edu/~ralph.stirling/classes/engr480/docs/Motoman/dx100_155494-1CD.pdf">Manual DX100</a>.</em>
</p>

<p align="center">
  <img src="https://github.com/user-attachments/assets/f5d66ac8-ff94-4257-8998-dfa2eb2c1c0e"  width="30%" />
  <br>
   <em>Tomado de <a   href="https://people.wallawalla.edu/~ralph.stirling/classes/engr480/docs/Motoman/dx100_155494-1CD.pdf">Manual DX100</a>.</em>
</p>

9. Seleccionamos la velocidad FAST o SLOW para el modo manual. El nivel de velocidad escogido corresponder√° al icono que se observa en la parte superior de la pantalla:

<p align="center">
  <img   src="https://github.com/user-attachments/assets/1c62ef8a-cea3-43ca-98ae-e4cc6c85b928" width="30%" />
  <br>
   <em>Tomado de: Presentaci√≥n Fundamentos de Rob√≥tica industrial.</em>
</p>


10. El bot√≥n para la selecci√≥n de modo de movimiento es el bot√≥n COORD, seg√∫n el modo de movimiento, se ver√° en la parte superior de la pantalla uno de los siguientes iconos:

<p align="center">
  <img src="https://github.com/user-attachments/assets/f0095fd0-997c-4e9f-beda-3a63c37f9b3e" width="30%" />
  <br>
   <em>Tomado de: Presentaci√≥n Fundamentos de Rob√≥tica industrial.</em>
</p>

11. En el modo de movimiento en el espacio de las articulaciones se ver√° este icono en la parte superior de la pantalla:

<p align="center">
  <img src="https://github.com/user-attachments/assets/78c3c575-b0a0-4f70-9aca-faf013e8af63" width="20%" />
  <br>
   <em>Tomado de: Presentaci√≥n Fundamentos de Rob√≥tica industrial.</em>
</p>

Los botones correspondientes a cada articulaci√≥n se observan a continuaci√≥n, donde los botones con la letra X Y o Z corresponder√°n al modo movimiento en el espacio de trabajo, mientras que S L U R B o T corresponder√°n al movimiento en el espacio de articulaci√≥n:


<p align="center">
  <img src="https://github.com/user-attachments/assets/f8318fa4-3f7a-4e89-849d-83f7369c755f" width="20%" />
  <br>
   <em>Tomado de: Presentaci√≥n Fundamentos de Rob√≥tica industrial.</em>
</p>

12. Si se trata del modo de movimiento en el espacio de trabajo se ver√° este icono en la parte superior de la pantalla:

<p align="center">
  <img alt="Pasted image 20251021203435" src="https://github.com/user-attachments/assets/adc2ae86-152d-4406-b958-cc27bf91c2bd"   width="20%" />
  <br>
   <em>Tomado de: Presentaci√≥n Fundamentos de Rob√≥tica industrial.</em>
</p>





## Niveles de velocidad para ense√±anza y c√≥mo identificarlos en interfaz


**Conceptos.**
- **Jog speed (Teach):** velocidad manual al mantener pulsada la tecla. Suele tener niveles/fine-tuning.
- **Override de reproducci√≥n (Play):** porcentaje que escala velocidades de programa cuando ‚Äúcorres‚Äù un Job.

**Gu√≠a pr√°ctica en controladores Motoman (DX100/DX200/YRC1000, nomenclatura t√≠pica):**
- **TEACH/JOG:** niveles **Lento / Medio / R√°pido** (o ‚ÄúFine/Coarse‚Äù) con ajuste incremental. Usa **Lento (1‚Äì20 mm/s)** en proximidad de interferencias; **Medio (20‚Äì150 mm/s)** para desplazamientos libres; **R√°pido (150‚Äì300+ mm/s)** solo en aire y con visibilidad.
- **PLAY:** **Speed Override** en % (p. ej., 5‚Äì100%). Para primeras pruebas, inicia en **5‚Äì10%** y sube gradualmente.
- **Indicadores en el HMI/Pendant:**
  - Barra de estado con **sistema de coordenadas activo** (BASE/USER/TOOL), **modo JOG** (JNT/XYZ/RxRyRz), y **velocidad** visible como **Teach Speed** o **Override %**.
  - Iconos/teclas dedicadas para cambiar **Fine/Coarse** y **SPEED OVERRIDE**. Verifica que el **servo ON** est√© habilitado y que **REMOTE/LOCAL** sea coherente con tu procedimiento.
- **Criterio de aceptaci√≥n para ense√±anza:**
  1) Ning√∫n eje supera l√≠mites ni zonas definidas de seguridad.
  2) En targets de precisi√≥n, captura con **Teach Speed baja** y **rotaciones Rx/Ry/Rz finas**.
  3) Repite el movimiento con **Override bajo** y confirma tiempos y clearances.

### Seleccion de velocidad de forma fisica en el Tech Pendant.
En la imagen continua se muestra cuales son los botones para seleccionar la velocidad de forma manual en el Tech Pendant.

<p align="center">
  <img width="500" alt="Diagrama" src="https://github.com/user-attachments/assets/4fe46496-607e-4f75-b090-1ae7c6a1f65d" />
</p>



## Funcionalidades de RoboDK y m√©todo de comunicaci√≥n con Motoman (con Python)

**Capacidades relevantes de RoboDK para esta c√©lula:**
- **Programaci√≥n offline (OLP)** multi‚Äëmarca: definici√≥n de marcos, herramientas, detecci√≥n de colisiones, generaci√≥n de trayectorias sobre superficies.
- **APIs** (Python/C#/C++/Matlab/Java) para automatizar importaciones CAD, c√°lculo de poses y post‚Äëprocesado a c√≥digo de robot.
- **Drivers online**: conexi√≥n directa por Ethernet a controladores soportados para ejecutar movimientos desde la simulaci√≥n (jog/MoveJ/MoveL) y verificar I/O b√°sicas.
- **Postprocesadores Motoman**: exportaci√≥n de **Jobs .JBI** listos para cargar por **USB/FTP** en el controlador.

**Formas de conexi√≥n Motoman ‚Üî RoboDK:**
1. **Online (Driver de RoboDK, Ethernet).**
   - Requisitos: IP del controlador, robot en **REMOTE**, permisos habilitados, servo listo. En RoboDK: clic derecho sobre el robot ‚Üí **Conectar al robot** ‚Üí configura IP ‚Üí **Conectar**.
   - Ventaja: pruebas inmediatas de trayectorias, verificaci√≥n de frames y TCP en vivo.
2. **Offline + Transferencia de programas (.JBI).**
   - En RoboDK: **Program ‚Üí Generate Program** usando el postprocesador Motoman. Transfiere por **USB** o **FTP** al controlador y ejecuta desde el pendant.
   - Ventaja: no requiere enlace en vivo; ideal para entornos sin red industrial abierta.
3. **API externa ‚Üí RoboDK ‚Üí Robot.**
   - Un script externo en Python controla RoboDK v√≠a API; RoboDK, a su vez, maneja el robot por driver o genera .JBI. √ötil para flujos de **automatizaci√≥n** e integraci√≥n con software de proceso.

**D√≥nde y c√≥mo pegar c√≥digo Python en RoboDK:**
- Opci√≥n A: en RoboDK, **Station ‚Üí Add ‚Üí Python Program**. Abre el editor integrado, pega el script y ejecuta con el bot√≥n **Run**.
- Opci√≥n B: **Tools ‚Üí Run Script** y selecciona tu `.py`.
- Opci√≥n C (externo): instala `robodk` (`pip install robodk`), mant√©n RoboDK abierto y ejecuta tu script desde la terminal/IDE. El script se conecta a la instancia activa de RoboDK.

**Ejemplo de script (conexi√≥n, selecci√≥n de robot, frames y figura ‚Äúrosa polar‚Äù)**

> Este script fue proporcionado por los docentes de la asignatura como ejemplo de aprendizaje, en el se asume que ya configuraste la IP del robot en el √≠tem de robot dentro de RoboDK y que el controlador est√° en **REMOTE**. El flujo es: API Python ‚Üí RoboDK ‚Üí Driver Motoman ‚Üí Robot.

```python
from robodk.robolink import *    # API para RoboDK
from robodk.robomath import *    # Funciones matem√°ticas
import math

# 1) Abrir conexi√≥n con RoboDK e inicializar
RDK = Robolink()

# Elegir un robot (si hay varios)
robot = RDK.ItemUserPick("Selecciona un robot", ITEM_TYPE_ROBOT)
if not robot.Valid():
    raise Exception("No se ha seleccionado un robot v√°lido.")

# 2) Conexi√≥n online al robot f√≠sico (IP configurada en el √≠tem del robot)
print("Conectando al robot...")
if not robot.Connect():
    raise Exception("No se pudo conectar. Verifica REMOTE en el controlador, IP/puerto y permisos.")

if not robot.ConnectedState():
    raise Exception("Conexi√≥n no establecida. Revisa el driver y la red.")

print("Robot conectado correctamente.")

# 3) Selecci√≥n de frame y herramienta
frame_name = "Frame_from_Target1"   # Ajusta el nombre al de tu estaci√≥n
frame = RDK.Item(frame_name, ITEM_TYPE_FRAME)
if not frame.Valid():
    raise Exception(f'No se encontr√≥ el Frame "{frame_name}".')

robot.setPoseFrame(frame)           # Trabajar en el marco seleccionado
robot.setPoseTool(robot.PoseTool()) # Usa la herramienta activa

# 4) Par√°metros de velocidad y suavizado
robot.setSpeed(300)   # mm/s (ense√±anza/validaci√≥n; ajusta seg√∫n tu pol√≠tica)
robot.setRounding(5)  # mm de blend (0 para esquinas agudas)

# 5) Par√°metros de la rosa polar r = A*sin(k*Œ∏)
num_points = 720
A = 150          # mm
k = 5            # p√©talos (si k impar ‚Üí k p√©talos; si par ‚Üí 2k)
z_surface = 0    # Plano de trabajo Z=0 del frame
z_safe = 50      # Altura segura

# 6) Aproximaci√≥n al centro en altura segura
robot.MoveJ(transl(0, 0, z_surface + z_safe))
robot.MoveL(transl(0, 0, z_surface))

# 7) Trazado de la figura
full_turn = 2*math.pi
for i in range(num_points + 1):
    t = i / num_points
    theta = full_turn * t
    r = A * math.sin(k * theta)
    x = r * math.cos(theta)
    y = r * math.sin(theta)
    robot.MoveL(transl(x, y, z_surface))

# 8) Salida segura
robot.MoveL(transl(x, y, z_surface + z_safe))
print(f"Figura completada en el frame '{frame_name}'.")
```

**Notas operativas y variantes de conexi√≥n:**
- **Driver configurado en el √≠tem del robot:** clic derecho sobre el robot en RoboDK ‚Üí **Conectar al robot** ‚Üí define **IP/puerto**. El script `robot.Connect()` reutiliza esa configuraci√≥n.
- **Solo offline:** omite `robot.Connect()` y usa RoboDK para **generar .JBI**; transfiere por USB/FTP.
- **Pruebas sin hardware:** si no hay controlador, el script simula sobre el modelo de RoboDK; valida colisiones y alcance, luego exporta a .JBI.
- **Seguridad:** activa l√≠mites, zonas y reduce `setSpeed` y `setRounding` durante primeras pruebas. Nunca ejecutes online sin barreras y sin consenso del equipo de seguridad.

---

## üß© RoboDK: aplicaciones y comunicaci√≥n con el robot

- **Aplicaciones**: simulaci√≥n 3D, programaci√≥n offline, generaci√≥n de c√≥digo, post‚Äëprocesadores, detecci√≥n de colisiones, calibraci√≥n, drivers online.  
- **Comunicaci√≥n (online)** con Motoman:  
  1) En RoboDK: **Connect ‚Üí Connect¬†Robot**.  
  2) Configurar **IP/puerto** del controlador (DX100/DX200).  
  3) **Seleccionar driver** Motoman y **probar ping**.  
  4) **Sincronizar**: mover en simulaci√≥n y ejecutar en robot (online).  
  5) Alternativa **offline**: **Generate¬†Program** ‚Üí exportar INFORM y cargar al controlador.

---

## üÜö RoboDK vs RobotStudio
<p align="center">
   <img width="200" alt="Robodk" src="https://github.com/user-attachments/assets/b88f16c8-7c25-4e7e-9710-28e4feb8e91f" />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  
  <img width="300" height="350" alt="Abb" src="https://github.com/user-attachments/assets/a3818a72-491e-48e0-b395-98417e7148f2" />
</p>




Prop√≥sito
---------
Comparar con criterio de ingenier√≠a dos ecosistemas de programaci√≥n y simulaci√≥n de robots industriales: RoboDK (multimarca) y RobotStudio (ABB). El objetivo es orientar decisiones de selecci√≥n, planeaci√≥n de celdas y preparaci√≥n de procesos (OLP, commissioning y soporte en planta).

1) Arquitectura y fidelidad de simulaci√≥n
-----------------------------------------
‚Ä¢ RoboDK
  - Motor cinem√°tico propio y modelos de robots de m√∫ltiples fabricantes. 
  - Foco en Programaci√≥n Offline (OLP), postprocesadores por marca/controlador y drivers ‚Äúonline‚Äù para pruebas en tiempo real.
  - Fidelidad ‚Äúcontrol‚Äëagnostic‚Äù: muy buena para cinem√°tica, envolventes, colisiones y orientaci√≥n herramienta; la exactitud temporal y de microcomandos depende del postprocesado y del driver.
‚Ä¢ RobotStudio (ABB)
  - Incluye Virtual Controller (VC) con firmware de ABB (RobotWare). Emula RAPID, planificador de movimiento, par√°metros del sistema y FlexPendant virtual.
  - Fidelidad alta para robots ABB: tiempos de ciclo, zonas de blend, eventos, E/S l√≥gicas y MultiMove se comportan casi 1:1 respecto a la celda real.
Implicaci√≥n pr√°ctica: si tu c√©lula es 100% ABB y necesitas pre‚Äëcomisionar con m√°xima fidelidad, RobotStudio domina. Si trabajas con marcas mixtas o cambias de robot a menudo, RoboDK ofrece mayor versatilidad.

2) Lenguajes, programaci√≥n y APIs
---------------------------------
‚Ä¢ RoboDK
  - Scripting/API: Python, C#, C++, Matlab, Java. Automatizaci√≥n de importaci√≥n CAD/CAM, generaci√≥n de trayectorias, c√°lculo de poses, simulaci√≥n y exportaci√≥n.
  - Postprocesadores: genera c√≥digo espec√≠fico (p.ej., RAPID, KRL, TP, JBI, INFORM, etc.) ajustable a est√°ndares de planta.
  - Macros para rutinas de calibraci√≥n, cambio de herramienta, ‚ÄúMachining‚Äù 3‚Äë5 ejes, pick&place y l√≥gica de celda b√°sica.
‚Ä¢ RobotStudio (ABB)
  - Programaci√≥n nativa en RAPID, m√≥dulos y tareas del sistema; edici√≥n con IntelliSense, depuraci√≥n y ejecuci√≥n paso a paso sobre el VC.
  - FlexPendant virtual y herramientas para Smart Components, Path Editor, MultiMove, SafeMove (configuraci√≥n), I/O simuladas y captura de eventos.
  - SDK y complementos especializados (PowerPacs) para soldadura, mecanizado, machine tending, paletizado, etc.
Resumen: RoboDK destaca por la orquestaci√≥n program√°tica y el soporte multi‚Äëlenguaje; RobotStudio por el ecosistema RAPID y el ciclo de vida completo ABB (desde dise√±o a mantenimiento).

3) Soporte de marcas y ecosistema
---------------------------------
‚Ä¢ RoboDK: librer√≠a amplia de robots, controladores y herramientas de m√∫ltiples fabricantes. Ideal para integradores, universidades y celdas donde cambian marcas o modelos.
‚Ä¢ RobotStudio: centrado en ABB con integraci√≥n profunda a caracter√≠sticas de controlador (MultiMove, EGM, SafeMove, LoadIdentify, etc.).

4) Trayectorias, superficies y procesos
--------------------------------------
‚Ä¢ RoboDK
  - Importa CAD/CAM (STEP/IGES/DXF, etc.) y genera trayectorias ‚Äúpath‚Äëon‚Äësurface‚Äù, tool orientation controlada, offsets y blends.
  - Plugins de mecanizado 3‚Äë5 ejes y utilidades para evitar singularidades, l√≠mites articulares y colisiones.
‚Ä¢ RobotStudio
  - Path Editor avanzado, creaci√≥n de targets sobre geometr√≠a, ajuste fino de zonas y velocidades reales del controlador.
  - PowerPacs espec√≠ficos por proceso (soldadura, corte, lijado, paletizado) con plantillas de mejores pr√°cticas ABB.
Conclusi√≥n: ambos resuelven ‚Äúpath sobre superficie‚Äù; RobotStudio ofrece ajuste fino con sem√°ntica del controlador ABB; RoboDK es flexible para m√∫ltiples marcas y CAM‚Äëlike workflows.

5) Online, I/O y pre‚Äëcomisionamiento
------------------------------------
‚Ä¢ RoboDK
  - Drivers online para ejecutar y testear en robots reales de varias marcas; utilidad para verificaci√≥n de poses, orientaciones e I/O simples.
  - La l√≥gica compleja de c√©lula suele residir en PLC/robot y se valida en campo.
‚Ä¢ RobotStudio
  - Virtual Controller con E/S l√≥gicas, tareas, eventos y emulaci√≥n de FlexPendant. Permite probar secuencias, handshakes y MultiMove antes del hardware.
Moraleja: para ‚Äúdry‚Äërun‚Äù de una c√©lula ABB, RobotStudio reduce horas de puesta en marcha. Para verificaci√≥n general y prototipos multi‚Äëmarca, RoboDK es r√°pido y suficiente.

6) Calibraci√≥n y precisi√≥n
--------------------------
‚Ä¢ RoboDK: herramientas para identificar TCP, base, calib. de herramienta y celda; mejora repetibilidad de OLP con medici√≥n externa cuando est√° disponible.
‚Ä¢ RobotStudio (ABB): flujo nativo con utilidades ABB (p.ej., LoadIdentify, tuneo de trayectorias, definici√≥n exacta de cinem√°tica y sistemas de coordenadas) y servicios de calibraci√≥n de fabricante.
Idea clave: la precisi√≥n absoluta depende de la calibraci√≥n mec√°nica y los par√°metros reales del robot. RoboDK y RobotStudio soportan esos flujos en distinto grado; con ABB, RobotStudio capitaliza par√°metros del propio controlador.

7) Integraci√≥n con PLC/OT y datos
---------------------------------
‚Ä¢ RoboDK: scripting y drivers para triggers, estados y E/S b√°sicas; para fieldbuses y OPC UA suele considerarse la capa de PLC/controlador real.
‚Ä¢ RobotStudio: simula E/S l√≥gicas del sistema ABB. Para buses industriales, la verificaci√≥n completa es en hardware, pero la l√≥gica RAPID se depura en el VC.

8) Licenciamiento y costos (orientativo)
----------------------------------------
‚Ä¢ RoboDK: coste inicial accesible, licencias perpetuas o suscripci√≥n, descuentos acad√©micos, m√≥dulos adicionales (p.ej., machining).
‚Ä¢ RobotStudio: versi√≥n base gratuita con limitaciones; licencias de VC y PowerPacs de costo corporativo; t√≠picamente m√°s alto que RoboDK, pero con retorno si la planta es ABB‚Äëcentrica.

9) Curva de aprendizaje y operaci√≥n
-----------------------------------
‚Ä¢ RoboDK: curva suave para OLP gen√©rica, scripting claro y documentaci√≥n pr√°ctica. Requiere entender postprocesadores por marca.
‚Ä¢ RobotStudio: requiere familiaridad con RAPID y conceptos del sistema ABB. A cambio, ofrece depuraci√≥n y an√°lisis con fidelidad de controlador.

10) Casos de uso recomendados
-----------------------------
‚Ä¢ Elige RoboDK cuando:
  - Tienes m√∫ltiples marcas de robot en la planta o en el laboratorio.
  - Tu foco es generar c√≥digo y simular r√°pido, con APIs para automatizar y estandarizar OLP.
  - Necesitas integrar flujos CAD/CAM con cambios frecuentes de herramienta y orientaci√≥n.
‚Ä¢ Elige RobotStudio cuando:
  - La c√©lula es ABB, requieres tiempos de ciclo realistas, MultiMove, SafeMove y pruebas de l√≥gica antes del hardware.
  - Quieres depurar RAPID, mapear I/O, validar zonas y hacer pre‚Äëcomisionamiento en alto detalle.

11) Matriz de decisi√≥n r√°pida
-----------------------------
‚Ä¢ ¬øEcosistema?: Multi‚Äëmarca ‚Üí RoboDK | Solo ABB ‚Üí RobotStudio.
‚Ä¢ ¬øFidelidad de controlador y tiempos de ciclo?: Alta prioridad ‚Üí RobotStudio | Media ‚Üí RoboDK.
‚Ä¢ ¬øBudget inicial?: Bajo/medio ‚Üí RoboDK | Medio/alto corporativo ‚Üí RobotStudio.
‚Ä¢ ¬øAutomatizaci√≥n por scripting multi‚Äëlenguaje?: RoboDK sobresale.
‚Ä¢ ¬øRAPID y Virtual Controller con FlexPendant?: RobotStudio.

12) Buenas pr√°cticas (aplican a ambos)
--------------------------------------
1. Calibra TCP y bases; usa fixtures de referencia.
2. Mant√©n una librer√≠a controlada de postprocesadores y plantillas por c√©lula.
3. Define tolerancias de orientaci√≥n y blending realistas; valida singularidades.
4. Versiona estaciones/proyectos y congela par√°metros antes de comisionar.
5. Ejecuta pilotos en vac√≠o y dry‚Äëruns con l√≠mites de seguridad conservadores.
6. Documenta offsets, sistemas de coordenadas y cambios de herramienta en un √∫nico ‚Äúdossier de celda‚Äù.

13) Limitaciones y riesgos frecuentes
-------------------------------------
‚Ä¢ Diferencias entre simulaci√≥n y planta por fricci√≥n, carga real, flexibilidad y holguras.
‚Ä¢ Captura parcial de l√≥gicas de seguridad y fieldbuses complejos en simulaci√≥n.
‚Ä¢ Exceso de confianza en tiempos de ciclo sin considerar perif√©ricos y PLC.
‚Ä¢ Postprocesadores desalineados con convenciones de f√°brica ‚Üí retrabajo en piso.

Conclusi√≥n
----------
RoboDK maximiza versatilidad y automatizaci√≥n multi‚Äëmarca con OLP √°gil y APIs potentes. RobotStudio maximiza fidelidad y productividad dentro del universo ABB al ofrecer un gemelo virtual de alto detalle. La elecci√≥n racional depende de tu ecosistema, del nivel de realismo requerido antes de tocar hardware y del presupuesto total de la c√©lula.


---

# üß≠ Trayectoria polar y Nombres en RoboDK 
## Flujograma de las trayectorias 
Se presenta el diagrama de flujo del proceso desarrollado para garantizar el cumplimiento de los requerimientos del proyecto.

<p align="center">
  <img width="300" height="1800" alt="Diagrama" src="https://github.com/user-attachments/assets/b4754bc3-e62c-48e4-bc11-7b8817980d58" />
</p>

## Plano de planta 
Se muestra el plano de planta del ecosistema de trabajo en RoboDK.
<p align="center">
  <img width="800" alt="Diagrama" src="https://github.com/user-attachments/assets/16f26b22-483d-4d7d-af32-d7808ffc726a" />
</p>


#### Plano lateral
Como visualizacion auxiliar se muestra un plano lateral del ecossistema en RoboDK, para tener mejor entendimiento de las posciones de cada elemento.

<p align="center">   
  <img width="397" height="2300" alt="Diagrama" src="https://github.com/user-attachments/assets/b1316eda-23ef-4b55-97e4-69671ab84608" />
</p>

## Codigo Python de trayectorias 
A continuacion se presenta el codigo que se desarrollo para realizar las trayectorias de lo nombres de integrantes y figura en forma polar.
```python
from robodk.robolink import *    # API para comunicarte con RoboDK
from robodk.robomath import *    # Funciones matem√°ticas
import math

#------------------------------------------------
# 1) Conexi√≥n a RoboDK e inicializaci√≥n
#------------------------------------------------
RDK = Robolink()

# Elegir un robot 
robot = RDK.ItemUserPick("Selecciona un robot", ITEM_TYPE_ROBOT)
if not robot.Valid():
    raise Exception("No se ha seleccionado un robot v√°lido.")

# Conectar al robot f√≠sico
#if not robot.Connect():
#    raise Exception("No se pudo conectar al robot. Verifica que est√© en modo remoto y que la configuraci√≥n sea correcta.")

# Confirmar conexi√≥n
#if not robot.ConnectedState():
#    raise Exception("El robot no est√° conectado correctamente. Revisa la conexi√≥n.")

#print("Robot conectado correctamente.")

#------------------------------------------------
# 2) Cargar el Frame  donde quieres dibujar
#------------------------------------------------
frame_name = "Frame_from_Target1"
frame = RDK.Item(frame_name, ITEM_TYPE_FRAME)
if not frame.Valid():
    raise Exception(f'No se encontr√≥ el Frame "{frame_name}" en la estaci√≥n.')

# Asignamos este frame al robot
robot.setPoseFrame(frame)
# Usamos la herramienta activa
robot.setPoseTool(robot.PoseTool())

# Ajustes de velocidad y blending
robot.setSpeed(300)   # mm/s - Ajusta seg√∫n necesites
robot.setRounding(5)  # blending (radio de curvatura)

robot.Pause(2)  # Espera 2 segundos

robot.MoveJ([0, 0, 0, 0, 0, 0])

#------------------------------------------------
# 3) Definiciones de letras y par√°metros de escritura
#------------------------------------------------

# Letras definidas en matriz 3x3
letras = {
    'C': [[2,2],[0,2],[0,0],[2,0]],
    'A': [[0,0],[1,2],[2,0]],
    'M': [[0,0],[0,2],[1,1],[2,2],[2,0]],
    'N': [[0,0],[0,2],[2,0],[2,2]],
    'I': [[1,0],[1,2]],
    'O': [[0,0],[2,0],[2,2],[0,2],[0,0]],
    'G': [[2,2],[0,2],[0,0],[2,0],[2,1],[0,1]],
    'B': [[0,0],[0,2],[2,2],[2,1],[0,1],[2,1],[2,0],[0,0]],
}

# Lista de nombres a escribir
nombres = ["cami", "gabo", "nico"]

# Par√°metros de dibujo
escala = 30             # tama√±o de cada paso en mm
espacio_letra = 70      # espacio entre letras
espacio_linea = 70      # espacio entre l√≠neas
z_surface = 0           # altura para escribir
z_safe = -50             # altura segura

#------------------------------------------------
# 4) Funci√≥n para mover el robot a dibujar una letra
#------------------------------------------------
def dibujar_letra(letra_coords, offset_x, offset_y):
    first = True
    last_pose = None  # Guardaremos la √∫ltima posici√≥n
    
    for punto in letra_coords:
        x = offset_x + punto[0] * escala
        y = offset_y + (2 - punto[1]) * escala  # invierte eje Y

        pose = transl(x, y, z_surface)
        pose_arriba = transl(x, y, z_surface + z_safe)

        if first:
            robot.MoveJ(pose_arriba)
            robot.MoveL(pose)
            first = False
        else:
            robot.MoveL(pose)
        
        last_pose = pose  # Actualizamos √∫ltima posici√≥n
    
    robot.MoveL(transl(last_pose[0,3], last_pose[1,3], z_surface + z_safe))

    return last_pose


#------------------------------------------------
# 5) Escribir los nombres letra por letra
#------------------------------------------------

# Escribir nombres en horizontal, uno por l√≠nea
ultima_pos = None

for row_index, nombre in enumerate(nombres):
    for col_index, letra in enumerate(nombre.upper()):
        if letra not in letras:
            continue

        offset_x = col_index * espacio_letra - 50  # ajustes
        offset_y = -row_index * espacio_linea

        ultima_pos = dibujar_letra(letras[letra], offset_x, offset_y)

print("¬°Nombres escritos con √©xito!")

# Finalmente, subir en Z seguro desde la √∫ltima posici√≥n
#if ultima_pos is not None:
#    x = ultima_pos[0,3]
#    y = ultima_pos[1,3]
#    robot.MoveL(transl(x, y, z_surface + z_safe))



#------------------------------------------------
# 6) Par√°metros de la figura (rosa polar)
#------------------------------------------------
num_points = 50       # Cu√°ntos puntos muestreamos (mayor = m√°s suave)
A = 50               # Amplitud (300 mm = radio m√°ximo)
k = 5                  # Par√°metro de la rosa (p√©talos). Si es impar, habr√° k p√©talos; si es par, 2k
z_surface = 0          # Z=0 en el plano del frame
z_safe = -50            # Altura segura para aproximarse y salir

#------------------------------------------------
# 7) Movimiento al centro en altura segura
#------------------------------------------------
# El centro de la rosa (r=0) corresponde a x=0, y=0
robot.MoveJ(transl(0, 0, z_surface + z_safe))

# Bajamos a la "superficie" (Z=0)
robot.MoveL(transl(0, 0, z_surface))

#------------------------------------------------
# 8) Dibujar la rosa polar
#    r = A * sin(k*theta)
#    x = r*cos(theta), y = r*sin(theta)
#------------------------------------------------
# Recorremos theta de 0 a 2*pi (una vuelta completa)
full_turn = 2*math.pi

for i in range(num_points+1):
    # Fracci√≥n entre 0 y 1
    t = i / num_points
    
    # √Ångulo actual
    theta = full_turn * t

    # Calculamos r
    r = A * (2 + math.sin(4 * theta))

    # Convertimos a coordenadas Cartesianas X, Y
    x = r * math.cos(theta) + 375
    y = r * math.sin(theta) 

    # Movemos linealmente (MoveL) en el plano del Frame
    robot.MoveL(transl(x, y, z_surface))

# Al terminar, subimos de nuevo para no chocar
robot.MoveL(transl(x, y, z_surface + z_safe))

print(f"¬°Figura (rosa polar) completada en el frame '{frame_name}'!")


robot.Pause(2)  # Espera 2 segundos

robot.MoveJ([0,0,0,0,0,0])
```
### Trayectoriaas realizadas
En color naranja se muestran los "dibujos" solicitados para el proyecto.
<p align="center">
  <img width="800" alt="Diagrama" src="https://github.com/user-attachments/assets/6e9e78b0-2a3d-4f59-944b-76bb66e2fcb5" />
</p>

## Simulacion de RoboDK
La simulacion de las trayectorias realizados con el codigo previamente mostrado se presenta mediante un video.

## Implementacion en Motoman MH6
La implementacion de las trayectorias realizados en la simulacion previamente mostrado se presenta mediante un video.






---

